<script>
const DIVIDING_LAT = 47.629536;        // Original blue/red line
const OUT_OF_BOUNDS_LAT = 47.6796281;  // NE Day Rd W line

const map = L.map('map');

L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png',{
  maxZoom:19,
  attribution:'&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
}).addTo(map);

// Blue/Red dividing line
L.polyline([[DIVIDING_LAT,-180],[DIVIDING_LAT,180]], {color:'#222', weight:3, dashArray:'8 6'}).addTo(map);

// Out-of-bounds line
L.polyline([[OUT_OF_BOUNDS_LAT,-180],[OUT_OF_BOUNDS_LAT,180]], {color:'#555', weight:2, dashArray:'6 4'}).addTo(map);

const teamLabel=document.getElementById('teamLabel');
const statusEl=document.getElementById('status');
const notify=document.getElementById('notify');
const notifySide=document.getElementById('notifySide');
const beep=document.getElementById('beep');

let marker=null, accuracyCircle=null, lastSide=null, lastNotifyAt=0;

function setTeamUI(isNorth){
  teamLabel.textContent='You are on the BLUE side';
  teamLabel.className='blue';
}

function sideFromLat(lat){
  return lat > DIVIDING_LAT ? 'blue' : 'red';
}

function showCrossNotify(side, latlng){
  const now=Date.now(); if(now-lastNotifyAt<3000) return; lastNotifyAt=now;
  notifySide.textContent = (side==='blue')?'BLUE': (side==='red')?'RED':'OUT OF BOUNDS';
  notify.style.display='block'; setTimeout(()=>{notify.style.display='none';},2500);
  beep.currentTime=0; beep.play().catch(()=>{});
  if('vibrate' in navigator) navigator.vibrate([150,80,150]);
  L.popup({autoClose:true, closeButton:false, closeOnClick:false, offset:[0,-10]})
    .setLatLng(latlng).setContent(`<b>Now on ${notifySide.textContent}</b>`).openOn(map);
  setTimeout(()=>map.closePopup(),2000);
}

function updatePosition(lat, lng, accuracy){
  if(!marker){
    marker = L.marker([lat, lng]).addTo(map);
    accuracyCircle = L.circle([lat, lng], {radius:accuracy||20, opacity:0.35}).addTo(map);
  } else {
    marker.setLatLng([lat, lng]);
    accuracyCircle.setLatLng([lat, lng]).setRadius(accuracy);
  }

  let currentSide;
  if(lat > OUT_OF_BOUNDS_LAT){
    currentSide = 'out';
    teamLabel.textContent = 'You are OUT OF BOUNDS';
    teamLabel.className = 'gray';
  } else {
    currentSide = sideFromLat(lat);
    teamLabel.textContent = currentSide==='blue' ? 'You are on the BLUE side' : 'You are on the RED side';
    teamLabel.className = currentSide==='blue' ? 'blue' : 'red';
  }

  statusEl.textContent = `Lat ${lat.toFixed(5)}, Lon ${lng.toFixed(5)} · ±${Math.round(accuracy)}m`;

  if(lastSide && lastSide !== currentSide){
    showCrossNotify(currentSide, [lat,lng]);
  }
  lastSide = currentSide;
}

if('geolocation' in navigator){
  navigator.geolocation.watchPosition(
    pos => updatePosition(pos.coords.latitude, pos.coords.longitude, pos.coords.accuracy),
    err => statusEl.textContent='Location error: '+err.message,
    {enableHighAccuracy:true, maximumAge:1000, timeout:10000}
  );
}

// -------- Load local GeoJSON and add blue/red + gray shading --------
fetch('bainbridge.geojson')
  .then(res=>res.json())
  .then(geojson=>{
    const islandBounds = L.geoJSON(geojson).getBounds();
    map.fitBounds(islandBounds, {padding:[20,20]});

    // Add red/blue sides
    geojson.features.forEach(f=>{
      const split = turf.lineSplit(f, turf.lineString([[-123,DIVIDING_LAT],[-122,DIVIDING_LAT]]));
      split.features.forEach(p=>{
        const centroid = turf.centroid(p);
        const lat = centroid.geometry.coordinates[1];
        const isNorth = lat > DIVIDING_LAT && lat <= OUT_OF_BOUNDS_LAT;
        L.geoJSON(p, {
          style:{
            color: isNorth ? '#0b69ff' : '#dc3b3b',
            fillColor: isNorth ? '#0b69ff' : '#dc3b3b',
            fillOpacity: 0.15,
            weight: 0
          }
        }).addTo(map);
      });
    });

    // Add gray shading for out-of-bounds area
    geojson.features.forEach(f=>{
      const split = turf.lineSplit(f, turf.lineString([[-123,OUT_OF_BOUNDS_LAT],[-122,OUT_OF_BOUNDS_LAT]]));
      split.features.forEach(p=>{
        const centroid = turf.centroid(p);
        const lat = centroid.geometry.coordinates[1];
        if(lat > OUT_OF_BOUNDS_LAT){
          L.geoJSON(p, {
            style:{
              fillColor:'#999',
              fillOpacity:0.2,
              weight:0
            }
          }).addTo(map);
        }
      });
    });

  })
  .catch(err=>console.error('Error loading GeoJSON:', err));
</script>
